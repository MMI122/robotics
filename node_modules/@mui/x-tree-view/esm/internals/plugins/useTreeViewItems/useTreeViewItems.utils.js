export const TREE_VIEW_ROOT_PARENT_ID = '__TREE_VIEW_ROOT_PARENT_ID__';
export const buildSiblingIndexes = siblings => {
  const siblingsIndexLookup = {};
  siblings.forEach((childId, index) => {
    siblingsIndexLookup[childId] = index;
  });
  return siblingsIndexLookup;
};

/**
 * Check if an item is disabled.
 * This method should only be used in selectors that are checking if several items are disabled.
 * Otherwise, use the `itemsSelector.isItemDisabled` selector.
 * @returns
 */
export const isItemDisabled = (itemMetaLookup, itemId) => {
  if (itemId == null) {
    return false;
  }
  let itemMeta = itemMetaLookup[itemId];

  // This can be called before the item has been added to the item map.
  if (!itemMeta) {
    return false;
  }
  if (itemMeta.disabled) {
    return true;
  }
  while (itemMeta.parentId != null) {
    itemMeta = itemMetaLookup[itemMeta.parentId];
    if (!itemMeta) {
      return false;
    }
    if (itemMeta.disabled) {
      return true;
    }
  }
  return false;
};
export function buildItemsState(parameters) {
  const {
    config,
    items: itemsParam,
    disabledItemsFocusable
  } = parameters;
  const itemMetaLookup = {};
  const itemModelLookup = {};
  const itemOrderedChildrenIdsLookup = {};
  const itemChildrenIndexesLookup = {};
  function processSiblings(items, parentId, depth) {
    const parentIdWithDefault = parentId ?? TREE_VIEW_ROOT_PARENT_ID;
    const {
      metaLookup,
      modelLookup,
      orderedChildrenIds,
      childrenIndexes,
      itemsChildren
    } = buildItemsLookups({
      config,
      items,
      parentId,
      depth,
      isItemExpandable: (item, children) => !!children && children.length > 0,
      otherItemsMetaLookup: itemMetaLookup
    });
    Object.assign(itemMetaLookup, metaLookup);
    Object.assign(itemModelLookup, modelLookup);
    itemOrderedChildrenIdsLookup[parentIdWithDefault] = orderedChildrenIds;
    itemChildrenIndexesLookup[parentIdWithDefault] = childrenIndexes;
    for (const item of itemsChildren) {
      processSiblings(item.children || [], item.id, depth + 1);
    }
  }
  processSiblings(itemsParam, null, 0);
  return {
    disabledItemsFocusable,
    itemMetaLookup,
    itemModelLookup,
    itemOrderedChildrenIdsLookup,
    itemChildrenIndexesLookup,
    domStructure: 'nested'
  };
}
export function buildItemsLookups(parameters) {
  const {
    config,
    items,
    parentId,
    depth,
    isItemExpandable,
    otherItemsMetaLookup
  } = parameters;
  const metaLookup = {};
  const modelLookup = {};
  const orderedChildrenIds = [];
  const itemsChildren = [];
  const processItem = item => {
    const id = config.getItemId ? config.getItemId(item) : item.id;
    checkId({
      id,
      parentId,
      item,
      itemMetaLookup: otherItemsMetaLookup,
      siblingsMetaLookup: metaLookup
    });
    const label = config.getItemLabel ? config.getItemLabel(item) : item.label;
    if (label == null) {
      throw new Error(['MUI X: The Tree View component requires all items to have a `label` property.', 'Alternatively, you can use the `getItemLabel` prop to specify a custom label for each item.', 'An item was provided without label in the `items` prop:', JSON.stringify(item)].join('\n'));
    }
    const children = (config.getItemChildren ? config.getItemChildren(item) : item.children) || [];
    itemsChildren.push({
      id,
      children
    });
    modelLookup[id] = item;
    metaLookup[id] = {
      id,
      label,
      parentId,
      idAttribute: undefined,
      expandable: isItemExpandable(item, children),
      disabled: config.isItemDisabled ? config.isItemDisabled(item) : false,
      depth
    };
    orderedChildrenIds.push(id);
  };
  for (const item of items) {
    processItem(item);
  }
  return {
    metaLookup,
    modelLookup,
    orderedChildrenIds,
    childrenIndexes: buildSiblingIndexes(orderedChildrenIds),
    itemsChildren
  };
}
function checkId({
  id,
  parentId,
  item,
  itemMetaLookup,
  siblingsMetaLookup
}) {
  if (id == null) {
    throw new Error(['MUI X: The Tree View component requires all items to have a unique `id` property.', 'Alternatively, you can use the `getItemId` prop to specify a custom id for each item.', 'An item was provided without id in the `items` prop:', JSON.stringify(item)].join('\n'));
  }
  if (siblingsMetaLookup[id] != null ||
  // Ignore items with the same parent id, because it's the same item from the previous generation.
  itemMetaLookup[id] != null && itemMetaLookup[id].parentId !== parentId) {
    throw new Error(['MUI X: The Tree View component requires all items to have a unique `id` property.', 'Alternatively, you can use the `getItemId` prop to specify a custom id for each item.', `Two items were provided with the same id in the \`items\` prop: "${id}"`].join('\n'));
  }
}